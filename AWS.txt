# node_publish.py - ì„¼ì„œ ë°ì´í„° ì‹œë®¬ë ˆì´í„° (collector_forwarder.py ëŒ€ì‘ ë²„ì „)
from awscrt import io, mqtt
from awsiot import mqtt_connection_builder
import json, time, random, os, pathlib, uuid

# ------------------ ì„¤ì • ------------------
ENDPOINT = "a3oedokc29sfh3-ats.iot.ap-southeast-2.amazonaws.com"
CLIENT_ID = f"sensor-publisher-{uuid.uuid4().hex[:8]}"  # ìœ ë‹ˆí¬ ID

PATH_CA   = "node1-RootCA1.pem"
PATH_CERT = "node1-cert.pem.crt"
PATH_KEY  = "node1-private.pem.key"

# ì„¼ì„œ í† í”½ (node_1, ì„¼ì„œ 3ê°œì”©)
TOPICS = {
    # ì˜¨ë„ 3ì±„ë„
    "temp_1": "sensor/node_1/temp_1",
    "temp_2": "sensor/node_1/temp_2",
    "temp_3": "sensor/node_1/temp_3",

    # CO2 3ì±„ë„
    "co2_1": "sensor/node_1/co2_1",
    "co2_2": "sensor/node_1/co2_2",
    "co2_3": "sensor/node_1/co2_3",

    # PM2.5 3ì±„ë„
    "pm25_1": "sensor/node_1/pm25_1",
    "pm25_2": "sensor/node_1/pm25_2",
    "pm25_3": "sensor/node_1/pm25_3",

    # PM10 3ì±„ë„
    "pm10_1": "sensor/node_1/pm10_1",
    "pm10_2": "sensor/node_1/pm10_2",
    "pm10_3": "sensor/node_1/pm10_3",
}

# ê¸°ë³¸ ì„¼ì„œ ë°ì´í„° ë²”ìœ„ (í‰ì†Œ ê°’)
BASE_RANGES = {
    "temp":  (20.0, 26.0),   # Â°C
    "co2":   (450, 800),     # ppm
    "pm25":  (5, 25),        # Âµg/mÂ³
    "pm10":  (10, 40),       # Âµg/mÂ³
}

def _abs(p):
    """ê²½ë¡œ ìë™ íƒìƒ‰"""
    if os.path.isabs(p):
        return p
    here = pathlib.Path(__file__).parent.resolve()
    for cand in [p, os.path.join(os.getcwd(), p), str(here / p), str(here / "certs" / p)]:
        if os.path.exists(cand):
            return cand
    return p

def _now():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())

# ------------------ ì—°ê²° ------------------
print(f"[{_now()}] Connecting to AWS IoT...")
print(f"  - endpoint = {ENDPOINT}")
print(f"  - clientId = {CLIENT_ID}")

elg = io.EventLoopGroup(1)
resolver = io.DefaultHostResolver(elg)
bootstrap = io.ClientBootstrap(elg, resolver)

conn = mqtt_connection_builder.mtls_from_path(
    endpoint=ENDPOINT,
    cert_filepath=_abs(PATH_CERT),
    pri_key_filepath=_abs(PATH_KEY),
    ca_filepath=_abs(PATH_CA),
    client_id=CLIENT_ID,
    clean_session=True,
    keep_alive_secs=30,
)

try:
    conn.connect().result(timeout=10)
    print(f"[{_now()}] âœ… Connected to AWS IoT Core")
except Exception as e:
    print(f"[{_now()}] âŒ Connection failed: {e}")
    exit(1)

# ------------------ collecting ON ë³´ë‚´ê¸° ------------------
CTRL_TOPIC = "control/node_1/collect"
try:
    ctrl_payload = json.dumps({"on": 1})
    conn.publish(
        topic=CTRL_TOPIC,
        payload=ctrl_payload,
        qos=mqtt.QoS.AT_LEAST_ONCE
    )
    print(f"[{_now()}] ğŸ“¤ CTRL â†’ on=1 (topic: {CTRL_TOPIC})")
except Exception as e:
    print(f"[{_now()}] âŒ Failed to send CTRL on=1: {e}")

# ------------------ ì„¼ì„œ ë°ì´í„° ë°œí–‰ ------------------
print(f"[{_now()}] ğŸ“¡ Publishing sensor data...")
print(f"[{_now()}] Press Ctrl+C to stop\n")

try:
    batch = 0
    while True:
        ts = int(time.time())
        batch += 1

        # ë°°ì¹˜ ë²ˆí˜¸ì— ë”°ë¼ ìŠ¤íŒŒì´í¬ ë°œìƒ ì—¬ë¶€ ê²°ì •
        spike = False

        # 10ë²ˆì§¸ ë°°ì¹˜ë§ˆë‹¤ ê°•í•˜ê²Œ ì˜¬ë ¤ì„œ ì•Œë¦¼ ì¡°ê±´ ê±°ì˜ í™•ì‹¤í•˜ê²Œ ë§Œì¡±
        if batch % 10 == 0:
            spike = True
            print(f"\n[{_now()}] ğŸ”¥ SPIKE BATCH #{batch} - CO2/PM ê°’ í¬ê²Œ ì˜¬ë¦¼ (ì•Œë¦¼ ìœ ë„)\n")

        for sensor_name, topic in TOPICS.items():
            # sensor_name ì˜ˆ: temp_1, co2_2, pm25_3 ...
            if sensor_name.startswith("temp"):
                base_min, base_max = BASE_RANGES["temp"]
                value = round(random.uniform(base_min, base_max), 1)

            elif sensor_name.startswith("co2"):
                base_min, base_max = BASE_RANGES["co2"]

                if spike:
                    # í™˜ê¸° ì•Œë¦¼ ì¡°ê±´ ì‰½ê²Œ ë§ì¶”ê¸°:
                    # CO2_now > 1200 ì •ë„ë¡œ í¬ê²Œ
                    value = random.randint(1200, 1800)
                else:
                    value = random.randint(base_min, base_max)

            elif sensor_name.startswith("pm25"):
                base_min, base_max = BASE_RANGES["pm25"]

                if spike:
                    # ë¨¼ì§€ ì•Œë¦¼ ì¡°ê±´: Dust_now > 50
                    value = random.randint(55, 90)
                else:
                    value = random.randint(base_min, base_max)

            elif sensor_name.startswith("pm10"):
                base_min, base_max = BASE_RANGES["pm10"]

                if spike:
                    # ë¨¼ì§€ ì•Œë¦¼ ì¡°ê±´: Dust_now > 50
                    value = random.randint(60, 120)
                else:
                    value = random.randint(base_min, base_max)

            else:
                # í˜¹ì‹œ ëª¨ë¥´ëŠ” ê¸°íƒ€ ì„¼ì„œ
                value = 0

            payload = json.dumps({
                "ts": ts,
                "value": value,
            })

            try:
                conn.publish(
                    topic=topic,
                    payload=payload,
                    qos=mqtt.QoS.AT_LEAST_ONCE
                )
                print(f"[{_now()}] ğŸ“¤ {sensor_name:8s} â†’ {str(value):>6} (topic: {topic})")
            except Exception as e:
                print(f"[{_now()}] âŒ Publish failed for {sensor_name}: {e}")

        print(f"[{_now()}] âœ… Batch #{batch} published ({len(TOPICS)} sensors)\n")

        # collector_forwarderì—ì„œ STACK_SIZE=10, CHECK_INTERVAL=60 ì´ë‹ˆê¹Œ
        # 5ì´ˆ ì£¼ê¸°ë¡œ 10ê°œ â‰’ 50ì´ˆ ë°ì´í„° -> Î”CO2, Î”Dust ê³„ì‚°ì— ì¶©ë¶„
        time.sleep(5)

except KeyboardInterrupt:
    print(f"\n[{_now()}] ğŸ›‘ Stopping...")
finally:
    try:
        conn.disconnect().result()
        print(f"[{_now()}] âœ… Disconnected")
    except Exception:
        pass
